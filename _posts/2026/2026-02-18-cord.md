---
layout: post
title: "Cord: Coordinating Trees of AI Agents"
tags: coding
---

I built [Cord](https://github.com/kimjune01/cord), a coordination protocol for trees of Claude Code agents. You give it a goal, and it figures out the rest.

```
cord run "Build a competitive landscape report for fintech"
```

What happens: a root agent decomposes the goal into subtasks — research competitors, research trends, deep analysis, write report. The research tasks run in parallel. The analysis waits for both. The report waits for the analysis. When everything completes, the root agent synthesizes a final output.

No workflow was hardcoded. The agent built the entire task tree at runtime.

---

## The Problem

Current agent orchestration falls into two camps:

**Imperative frameworks** (LangGraph, AutoGen, Swarm) embed coordination logic in application code. There's no single artifact that describes the work. Hard to inspect mid-execution, hard to hand off.

**Declarative workflows** (Airflow, Argo) are designed for deterministic microservice orchestration. They don't handle agents that need to restructure their own work, ask clarifying questions, or operate with varying degrees of shared context.

Neither gives you runtime self-modification — an agent deciding mid-task that it needs to split the work differently than originally planned.

## Five Primitives

Cord has five node types:

| Type | What it does |
|------|-------------|
| `goal` | Root objective |
| `spawn` | Child with scoped context (like hiring a contractor) |
| `fork` | Child with inherited context (like briefing a team member) |
| `serial` | Ordered sequence |
| `ask` | Request input from human/parent/children |

The interesting one is `spawn` vs `fork`. A spawned agent gets a clean slate — just its prompt and dependency results. A forked agent gets all completed sibling results injected into its context. This is a first-class distinction about what the child *knows*, not when it runs.

Dependencies control timing: any node can declare `blocked_by` — a list of nodes that must complete before it starts.

## How It Works

```
You                    Engine                 Agents
 │                       │                      │
 │  cord run "goal"      │                      │
 │──────────────────────>│                      │
 │                       │  launch root agent   │
 │                       │─────────────────────>│
 │                       │                      │ spawn("#2", ...)
 │                       │                      │ spawn("#3", ...)
 │                       │                      │ complete("decomposed")
 │                       │<─────────────────────│
 │                       │                      │
 │                       │  #2 and #3 ready     │
 │                       │  launch both         │
 │                       │─────────────────────>│ (parallel)
 │                       │                      │ complete("result")
 │                       │<─────────────────────│
 │                       │                      │
 │                       │  all children done   │
 │                       │  relaunch root for   │
 │                       │  synthesis            │
 │                       │─────────────────────>│
 │                       │                      │ complete("final")
 │  Done.                │<─────────────────────│
```

Each agent is a Claude Code CLI process. Each gets MCP tools — `spawn`, `fork`, `complete`, `read_tree`, `stop`, `ask` — backed by a shared SQLite database. The engine polls the database, launches agents when their dependencies are met, and renders a live TUI.

The agents don't know they're in a coordination tree. They see tools and use them. The protocol — authority scoping, dependency resolution, result injection — is enforced by the MCP server.

## What I Learned Building It

**Agents decompose naturally.** When given `spawn()` and a complex goal, Claude breaks work into 3-6 subtasks with correct dependency ordering. No special prompting needed beyond "you have MCP tools available."

**Fork vs spawn is intuitive to the model.** In testing, Claude correctly chose `fork` for analysis tasks that need accumulated context and `spawn` for independent research tasks. It described the distinction as "contractor vs team member" — the exact mental model from the spec.

**Authority through error handling works.** Agents don't preemptively check permissions. They try an action, get rejected if unauthorized, and escalate via `ask`. This is actually the right pattern — the runtime is the guardrail, not the agent's judgment.

**SQLite handles the concurrency.** Multiple agent processes (each with its own MCP server) read and write the same database concurrently. WAL mode handles it. No custom file locking, no parse-mutate-serialize cycles.

**The two-phase lifecycle is key.** An agent decomposes (creates children, calls `complete`). The engine waits for children. When all finish, the engine relaunches the parent with a synthesis prompt. This lets any node in the tree decide at runtime whether to do the work itself or delegate.

## What This Implementation Is Not

This is one implementation of the Cord protocol. The protocol itself — five primitives, dependency resolution, authority scoping, two-phase lifecycle — is independent of the backing store, transport, and agent runtime.

You could implement Cord with:
- **Redis** for pub/sub instead of polling
- **Postgres** for multi-machine coordination
- **Claude API directly** instead of the CLI (no subprocess overhead)
- **Multiple LLM providers** — GPT for some nodes, Claude for others
- **Human workers** for some nodes (the `ask` primitive already models this)

The most interesting alternative is probably a centralized HTTP server with the Claude API directly. No CLI subprocess overhead, streaming results, hundreds of concurrent agents.

## Try It

```bash
git clone https://github.com/kimjune01/cord.git
cd cord
uv sync
cord run "your goal here" --budget 2.0
```

Requires [Claude Code CLI](https://docs.anthropic.com/en/docs/claude-code) and a subscription that includes it.

~500 lines of Python. SQLite + MCP. [RFC](https://github.com/kimjune01/cord/blob/master/RFC.md) describes the full protocol.

[GitHub](https://github.com/kimjune01/cord)
